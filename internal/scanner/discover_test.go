package scanner

import (
	"os"
	"path/filepath"
	"strings"
	"testing"

	"github.com/opd-ai/go-stats-generator/internal/config"
)

// Helper function to create temporary test files
func createTestFiles(t *testing.T, files map[string]string) string {
	t.Helper()

	tempDir, err := os.MkdirTemp("", "discover_test")
	if err != nil {
		t.Fatalf("Failed to create temp dir: %v", err)
	}

	for path, content := range files {
		fullPath := filepath.Join(tempDir, path)
		dir := filepath.Dir(fullPath)

		if err := os.MkdirAll(dir, 0755); err != nil {
			t.Fatalf("Failed to create directory %s: %v", dir, err)
		}

		if err := os.WriteFile(fullPath, []byte(content), 0644); err != nil {
			t.Fatalf("Failed to write file %s: %v", fullPath, err)
		}
	}

	return tempDir
}

func TestNewDiscoverer(t *testing.T) {
	cfg := &config.FilterConfig{
		SkipVendor: true,
	}

	discoverer := NewDiscoverer(cfg)

	if discoverer == nil {
		t.Fatal("NewDiscoverer returned nil")
	}

	if discoverer.config != cfg {
		t.Error("Discoverer config not set correctly")
	}

	if discoverer.fset == nil {
		t.Error("FileSet not initialized")
	}
}

func TestDiscoverFiles_BasicFunctionality(t *testing.T) {
	testFiles := map[string]string{
		"main.go":       "package main\n\nfunc main() {}\n",
		"utils.go":      "package main\n\nfunc helper() {}\n",
		"main_test.go":  "package main\n\nimport \"testing\"\n",
		"nongofile.txt": "not a go file",
		"subdir/lib.go": "package lib\n\nfunc Library() {}\n",
	}

	tempDir := createTestFiles(t, testFiles)
	defer os.RemoveAll(tempDir)

	cfg := &config.FilterConfig{}
	discoverer := NewDiscoverer(cfg)

	files, err := discoverer.DiscoverFiles(tempDir)
	if err != nil {
		t.Fatalf("DiscoverFiles failed: %v", err)
	}

	// Should find 4 Go files (excluding nongofile.txt)
	expectedCount := 4
	if len(files) != expectedCount {
		t.Errorf("Expected %d files, got %d", expectedCount, len(files))
	}

	// Check that all discovered files are Go files
	for _, file := range files {
		if !strings.HasSuffix(file.Path, ".go") {
			t.Errorf("Non-Go file discovered: %s", file.Path)
		}
	}
}

func TestDiscoverFiles_SkipTestFiles(t *testing.T) {
	testFiles := map[string]string{
		"main.go":      "package main\n\nfunc main() {}\n",
		"main_test.go": "package main\n\nimport \"testing\"\n",
		"helper.go":    "package main\n\nfunc helper() {}\n",
	}

	tempDir := createTestFiles(t, testFiles)
	defer os.RemoveAll(tempDir)

	cfg := &config.FilterConfig{
		SkipTestFiles: true,
	}
	discoverer := NewDiscoverer(cfg)

	files, err := discoverer.DiscoverFiles(tempDir)
	if err != nil {
		t.Fatalf("DiscoverFiles failed: %v", err)
	}

	// Should find 2 files (excluding test file)
	expectedCount := 2
	if len(files) != expectedCount {
		t.Errorf("Expected %d files, got %d", expectedCount, len(files))
	}

	// Verify no test files are included
	for _, file := range files {
		if file.IsTestFile {
			t.Errorf("Test file should have been skipped: %s", file.Path)
		}
	}
}

func TestDiscoverFiles_SkipVendor(t *testing.T) {
	testFiles := map[string]string{
		"main.go":            "package main\n\nfunc main() {}\n",
		"vendor/lib/lib.go":  "package lib\n\nfunc Library() {}\n",
		"internal/helper.go": "package internal\n\nfunc Helper() {}\n",
	}

	tempDir := createTestFiles(t, testFiles)
	defer os.RemoveAll(tempDir)

	cfg := &config.FilterConfig{
		SkipVendor: true,
	}
	discoverer := NewDiscoverer(cfg)

	files, err := discoverer.DiscoverFiles(tempDir)
	if err != nil {
		t.Fatalf("DiscoverFiles failed: %v", err)
	}

	// Should find 2 files (excluding vendor)
	expectedCount := 2
	if len(files) != expectedCount {
		t.Errorf("Expected %d files, got %d", expectedCount, len(files))
	}

	// Verify no vendor files are included
	for _, file := range files {
		if strings.Contains(file.RelPath, "vendor") {
			t.Errorf("Vendor file should have been skipped: %s", file.RelPath)
		}
	}
}

func TestDiscoverFiles_SkipGenerated(t *testing.T) {
	testFiles := map[string]string{
		"main.go": "package main\n\nfunc main() {}\n",
		"generated.go": `// Code generated by protoc-gen-go. DO NOT EDIT.
package main

func Generated() {}`,
		"autogenerated.go": `// This file was generated automatically
package main

func AutoGenerated() {}`,
	}

	tempDir := createTestFiles(t, testFiles)
	defer os.RemoveAll(tempDir)

	cfg := &config.FilterConfig{
		SkipGenerated: true,
	}
	discoverer := NewDiscoverer(cfg)

	files, err := discoverer.DiscoverFiles(tempDir)
	if err != nil {
		t.Fatalf("DiscoverFiles failed: %v", err)
	}

	// Should find 1 file (excluding generated files)
	expectedCount := 1
	if len(files) != expectedCount {
		t.Errorf("Expected %d files, got %d", expectedCount, len(files))
	}

	// Verify no generated files are included
	for _, file := range files {
		if file.IsGenerated {
			t.Errorf("Generated file should have been skipped: %s", file.Path)
		}
	}
}

func TestDiscoverFiles_IncludePatterns(t *testing.T) {
	testFiles := map[string]string{
		"main.go":         "package main\n\nfunc main() {}\n",
		"cmd/cli.go":      "package cmd\n\nfunc CLI() {}\n",
		"internal/lib.go": "package internal\n\nfunc Lib() {}\n",
		"test/helper.go":  "package test\n\nfunc Helper() {}\n",
	}

	tempDir := createTestFiles(t, testFiles)
	defer os.RemoveAll(tempDir)

	cfg := &config.FilterConfig{
		IncludePatterns: []string{"cmd/*.go", "main.go"},
	}
	discoverer := NewDiscoverer(cfg)

	files, err := discoverer.DiscoverFiles(tempDir)
	if err != nil {
		t.Fatalf("DiscoverFiles failed: %v", err)
	}

	// Should find 2 files matching patterns
	expectedCount := 2
	if len(files) != expectedCount {
		t.Errorf("Expected %d files, got %d", expectedCount, len(files))
	}

	// Verify only files matching patterns are included
	validPaths := map[string]bool{
		"main.go":    true,
		"cmd/cli.go": true,
	}

	for _, file := range files {
		if !validPaths[file.RelPath] {
			t.Errorf("Unexpected file included: %s", file.RelPath)
		}
	}
}

func TestDiscoverFiles_ExcludePatterns(t *testing.T) {
	testFiles := map[string]string{
		"main.go":      "package main\n\nfunc main() {}\n",
		"helper.go":    "package main\n\nfunc helper() {}\n",
		"generated.go": "package main\n\nfunc generated() {}\n",
	}

	tempDir := createTestFiles(t, testFiles)
	defer os.RemoveAll(tempDir)

	cfg := &config.FilterConfig{
		ExcludePatterns: []string{"generated.go"},
	}
	discoverer := NewDiscoverer(cfg)

	files, err := discoverer.DiscoverFiles(tempDir)
	if err != nil {
		t.Fatalf("DiscoverFiles failed: %v", err)
	}

	// Should find 2 files (excluding generated.go)
	expectedCount := 2
	if len(files) != expectedCount {
		t.Errorf("Expected %d files, got %d", expectedCount, len(files))
	}

	// Verify excluded file is not included
	for _, file := range files {
		if file.RelPath == "generated.go" {
			t.Errorf("Excluded file should not be included: %s", file.RelPath)
		}
	}
}

func TestDiscoverFiles_MaxFileSize(t *testing.T) {
	// Create a large file content (>1KB)
	largeContent := "package main\n\n" + strings.Repeat("// Large comment\n", 100)

	testFiles := map[string]string{
		"small.go": "package main\n\nfunc small() {}\n",
		"large.go": largeContent,
	}

	tempDir := createTestFiles(t, testFiles)
	defer os.RemoveAll(tempDir)

	cfg := &config.FilterConfig{
		MaxFileSizeKB: 1, // 1KB limit
	}
	discoverer := NewDiscoverer(cfg)

	files, err := discoverer.DiscoverFiles(tempDir)
	if err != nil {
		t.Fatalf("DiscoverFiles failed: %v", err)
	}

	// Should find only the small file
	expectedCount := 1
	if len(files) != expectedCount {
		t.Errorf("Expected %d files, got %d", expectedCount, len(files))
	}

	if len(files) > 0 && files[0].RelPath != "small.go" {
		t.Errorf("Expected small.go, got %s", files[0].RelPath)
	}
}

func TestAnalyzeFile_BasicInfo(t *testing.T) {
	testFiles := map[string]string{
		"example.go": "package example\n\nfunc Example() {}\n",
	}

	tempDir := createTestFiles(t, testFiles)
	defer os.RemoveAll(tempDir)

	cfg := &config.FilterConfig{}
	discoverer := NewDiscoverer(cfg)

	filePath := filepath.Join(tempDir, "example.go")
	info, err := os.Stat(filePath)
	if err != nil {
		t.Fatalf("Failed to stat file: %v", err)
	}

	fileInfo, err := discoverer.analyzeFile(filePath, tempDir, info)
	if err != nil {
		t.Fatalf("analyzeFile failed: %v", err)
	}

	if fileInfo.Package != "example" {
		t.Errorf("Expected package 'example', got '%s'", fileInfo.Package)
	}

	if fileInfo.RelPath != "example.go" {
		t.Errorf("Expected RelPath 'example.go', got '%s'", fileInfo.RelPath)
	}

	if fileInfo.IsTestFile {
		t.Error("File should not be marked as test file")
	}

	if fileInfo.IsGenerated {
		t.Error("File should not be marked as generated")
	}
}

func TestAnalyzeFile_TestFile(t *testing.T) {
	testFiles := map[string]string{
		"example_test.go": "package example\n\nimport \"testing\"\n",
	}

	tempDir := createTestFiles(t, testFiles)
	defer os.RemoveAll(tempDir)

	cfg := &config.FilterConfig{}
	discoverer := NewDiscoverer(cfg)

	filePath := filepath.Join(tempDir, "example_test.go")
	info, err := os.Stat(filePath)
	if err != nil {
		t.Fatalf("Failed to stat file: %v", err)
	}

	fileInfo, err := discoverer.analyzeFile(filePath, tempDir, info)
	if err != nil {
		t.Fatalf("analyzeFile failed: %v", err)
	}

	if !fileInfo.IsTestFile {
		t.Error("File should be marked as test file")
	}
}

func TestIsGeneratedFile(t *testing.T) {
	tests := []struct {
		name     string
		content  string
		expected bool
	}{
		{
			name:     "NotGenerated",
			content:  "package main\n\nfunc main() {}\n",
			expected: false,
		},
		{
			name:     "CodeGenerated",
			content:  "// Code generated by protoc-gen-go. DO NOT EDIT.\npackage main\n",
			expected: true,
		},
		{
			name:     "DoNotEdit",
			content:  "// DO NOT EDIT this file\npackage main\n",
			expected: true,
		},
		{
			name:     "AutoGenerated",
			content:  "// This file was autogenerated\npackage main\n",
			expected: true,
		},
		{
			name:     "GeneratedAutomatically",
			content:  "// Generated automatically by tool\npackage main\n",
			expected: true,
		},
		{
			name:     "ThisFileWasGenerated",
			content:  "// This file was generated by generator\npackage main\n",
			expected: true,
		},
		{
			name:     "CaseInsensitive",
			content:  "// CODE GENERATED BY TOOL. DO NOT EDIT.\npackage main\n",
			expected: true,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			result := isGeneratedFile(tt.content)
			if result != tt.expected {
				t.Errorf("isGeneratedFile() = %v, expected %v", result, tt.expected)
			}
		})
	}
}

func TestContainsPathSegment(t *testing.T) {
	tests := []struct {
		name     string
		path     string
		segment  string
		expected bool
	}{
		{
			name:     "ContainsSegment",
			path:     "src/vendor/lib",
			segment:  "vendor",
			expected: true,
		},
		{
			name:     "DoesNotContainSegment",
			path:     "src/internal/lib",
			segment:  "vendor",
			expected: false,
		},
		{
			name:     "SingleSegment",
			path:     "vendor",
			segment:  "vendor",
			expected: true,
		},
		{
			name:     "PartialMatch",
			path:     "src/vendorish/lib",
			segment:  "vendor",
			expected: false,
		},
		{
			name:     "WindowsPath",
			path:     "src\\vendor\\lib",
			segment:  "vendor",
			expected: true,
		},
		{
			name:     "EmptyPath",
			path:     "",
			segment:  "vendor",
			expected: false,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			result := containsPathSegment(tt.path, tt.segment)
			if result != tt.expected {
				t.Errorf("containsPathSegment(%q, %q) = %v, expected %v",
					tt.path, tt.segment, result, tt.expected)
			}
		})
	}
}

func TestParseFile(t *testing.T) {
	testFiles := map[string]string{
		"valid.go": `package main

import "fmt"

func main() {
	fmt.Println("Hello, World!")
}`,
		"invalid.go": "package main\n\nfunc invalid syntax {}\n",
	}

	tempDir := createTestFiles(t, testFiles)
	defer os.RemoveAll(tempDir)

	cfg := &config.FilterConfig{}
	discoverer := NewDiscoverer(cfg)

	t.Run("ValidFile", func(t *testing.T) {
		validPath := filepath.Join(tempDir, "valid.go")
		file, err := discoverer.ParseFile(validPath)
		if err != nil {
			t.Fatalf("ParseFile failed: %v", err)
		}

		if file == nil {
			t.Fatal("ParseFile returned nil AST")
		}

		if file.Name.Name != "main" {
			t.Errorf("Expected package 'main', got '%s'", file.Name.Name)
		}
	})

	t.Run("InvalidFile", func(t *testing.T) {
		invalidPath := filepath.Join(tempDir, "invalid.go")
		_, err := discoverer.ParseFile(invalidPath)
		if err == nil {
			t.Error("ParseFile should have failed for invalid syntax")
		}
	})

	t.Run("NonExistentFile", func(t *testing.T) {
		nonExistentPath := filepath.Join(tempDir, "nonexistent.go")
		_, err := discoverer.ParseFile(nonExistentPath)
		if err == nil {
			t.Error("ParseFile should have failed for non-existent file")
		}
	})
}

func TestGetFileSet(t *testing.T) {
	cfg := &config.FilterConfig{}
	discoverer := NewDiscoverer(cfg)

	fset := discoverer.GetFileSet()
	if fset == nil {
		t.Error("GetFileSet returned nil")
	}

	// Verify it's the same instance
	if fset != discoverer.fset {
		t.Error("GetFileSet returned different instance than internal fset")
	}
}

func TestDiscoverFiles_EmptyDirectory(t *testing.T) {
	tempDir, err := os.MkdirTemp("", "empty_test")
	if err != nil {
		t.Fatalf("Failed to create temp dir: %v", err)
	}
	defer os.RemoveAll(tempDir)

	cfg := &config.FilterConfig{}
	discoverer := NewDiscoverer(cfg)

	files, err := discoverer.DiscoverFiles(tempDir)
	if err != nil {
		t.Fatalf("DiscoverFiles failed: %v", err)
	}

	if len(files) != 0 {
		t.Errorf("Expected 0 files in empty directory, got %d", len(files))
	}
}

func TestDiscoverFiles_NonExistentDirectory(t *testing.T) {
	cfg := &config.FilterConfig{}
	discoverer := NewDiscoverer(cfg)

	_, err := discoverer.DiscoverFiles("/nonexistent/directory")
	if err == nil {
		t.Error("DiscoverFiles should have failed for non-existent directory")
	}
}
